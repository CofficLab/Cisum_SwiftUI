import Foundation
import MagicKit
import OSLog

class DiskiCloud: ObservableObject, Disk, SuperLog, SuperThread {
    static var label = "‚òÅÔ∏è DiskiCloud::"
    static let cloudRoot = Config.cloudDocumentsDir

    let emoji = "üê∂"

    // MARK: Á£ÅÁõòÁöÑÊåÇËΩΩÁõÆÂΩï

    static func getMountedURL() -> URL? {
        let verbose = false

        guard let cloudRoot = Self.cloudRoot else {
            os_log(.error, "\(self.label)Êó†Ê≥ïËé∑ÂèñÊ†πÁõÆÂΩïÔºåÂõ†‰∏∫ CloudRoot=nil")

            return nil
        }

        if verbose {
            os_log("\(Self.label)Á£ÅÁõòÁöÑÊ†πÁõÆÂΩïÊòØ \(cloudRoot.path())")
        }

        if FileManager.default.fileExists(atPath: cloudRoot.path(percentEncoded: false)) == false {
            os_log(.error, "CloudRoot ÁõÆÂΩï‰∏çÂ≠òÂú®")
        }

        return cloudRoot
    }

    var root: URL
    var queue = DispatchQueue(label: "DiskiCloud", qos: .background)
    var fileManager = FileManager.default
    var cloudHandler = iCloudHandler()
    var bg = Config.bgQueue
    var query: ItemQuery
    var verbose = true
    var onUpdated: (_ items: DiskFileGroup) -> Void = { items in
        os_log("\(Logger.isMain)\(DiskiCloud.label)updated with items.count=\(items.count)")
    }

    required init(root: URL) {
        let queue = OperationQueue()
        queue.maxConcurrentOperationCount = 1

        self.root = root
        self.query = ItemQuery(queue: queue)
    }
}

// MARK: GetTree

extension DiskiCloud {
    func getRoot() -> DiskFile {
        DiskFile.fromURL(root)
    }

    func next(_ url: URL) -> DiskFile? {
        DiskFile(url: url).nextDiskFile()
    }

    func getTotal() -> Int {
        0
    }
}

// MARK: Delete

extension DiskiCloud {
    func deleteFiles(_ urls: [URL]) {
        for url in urls {
            if verbose {
                os_log("\(self.label)Âà†Èô§ \(url.lastPathComponent)")
            }

            if fileManager.fileExists(atPath: url.path) == false {
                continue
            }

            try? fileManager.removeItem(at: url)
        }
    }

    func deleteFile(_ url: URL) {
        deleteFiles([url])
    }
}

extension DiskiCloud {
    func clearFolderContents(atPath path: String) {
        let fileManager = FileManager.default
        do {
            let contents = try fileManager.contentsOfDirectory(atPath: path)
            for item in contents {
                let itemPath = URL(fileURLWithPath: path).appendingPathComponent(item).path
                try fileManager.removeItem(atPath: itemPath)
            }
        } catch {
            os_log("\(Logger.isMain)\(self.label)clearFolderContents error: \(error.localizedDescription)")
        }
    }
}

// MARK: Copy

extension DiskiCloud {
    func copyTo(url: URL, reason: String) throws {
        let verbose = true
        if verbose {
            os_log("\(self.t)copy \(url.lastPathComponent) because of \(reason)")
        }

        // ÁõÆÁöÑÂú∞Â∑≤ÁªèÂ≠òÂú®ÂêåÂêçÊñá‰ª∂
        var d = root.appendingPathComponent(url.lastPathComponent)
        var times = 1
        let fileName = url.deletingPathExtension().lastPathComponent
        let ext = url.pathExtension
        while fileManager.fileExists(atPath: d.path) {
            d = d.deletingLastPathComponent()
                .appendingPathComponent("\(fileName)-\(times)")
                .appendingPathExtension(ext)
            times += 1
            os_log("\(self.t)copy  -> \(d.lastPathComponent)")
        }

        os_log("\(self.t)copy ÂºÄÂßãÂ§çÂà∂ \(url.lastPathComponent)")
        os_log("  ‚û°Ô∏è ‰ªéÔºö \(url.relativePath)")
        os_log("  ‚û°Ô∏è Âà∞Ôºö \(d.relativePath)")

        do {
            // Ê£ÄÊü•Ê∫êÊñá‰ª∂ÁöÑËÆøÈóÆÊùÉÈôê
            guard fileManager.isReadableFile(atPath: url.path) else {
                throw NSError(domain: "DiskiCloud", code: 403, userInfo: [NSLocalizedDescriptionKey: "Ê≤°ÊúâËØªÂèñÊ∫êÊñá‰ª∂ÁöÑÊùÉÈôê: \(url.path)"])
            }

            // Ê£ÄÊü•ÁõÆÊ†áÊñá‰ª∂Â§πÊòØÂê¶Â≠òÂú®ÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÂàõÂª∫
            let destinationFolder = d.deletingLastPathComponent()
            if !fileManager.fileExists(atPath: destinationFolder.path) {
                try fileManager.createDirectory(at: destinationFolder, withIntermediateDirectories: true, attributes: nil)
                os_log("\(self.t)ÂàõÂª∫ÁõÆÊ†áÊñá‰ª∂Â§π: \(destinationFolder.path)")
            }

            // Ê£ÄÊü•ÁõÆÊ†áÊñá‰ª∂Â§πÁöÑËÆøÈóÆÊùÉÈôê
            guard fileManager.isWritableFile(atPath: destinationFolder.path) else {
                throw NSError(domain: "DiskiCloud", code: 403, userInfo: [NSLocalizedDescriptionKey: "Ê≤°ÊúâÂÜôÂÖ•ÁõÆÊ†áÊñá‰ª∂Â§πÁöÑÊùÉÈôê: \(destinationFolder.path)"])
            }

            // ÊâßË°åÂ§çÂà∂Êìç‰Ωú
            try fileManager.copyItem(at: url, to: d)
            os_log("\(self.t)Â§çÂà∂ÊàêÂäü: \(d.path)")
        } catch {
            os_log(.error, "\(self.t)Â§çÂà∂Êñá‰ª∂ÂèëÁîüÈîôËØØ -> \(error.localizedDescription)")

            // Ê∑ªÂä†Êõ¥Â§öËØäÊñ≠‰ø°ÊÅØ
            if let nsError = error as NSError? {
                os_log(.error, "\(self.t)ÈîôËØØÂüü: \(nsError.domain)")
                os_log(.error, "\(self.t)ÈîôËØØ‰ª£Á†Å: \(nsError.code)")
                if let failureReason = nsError.localizedFailureReason {
                    os_log(.error, "\(self.t)Â§±Ë¥•ÂéüÂõ†: \(failureReason)")
                }
                if let recoverySuggestion = nsError.localizedRecoverySuggestion {
                    os_log(.error, "\(self.t)ÊÅ¢Â§çÂª∫ËÆÆ: \(recoverySuggestion)")
                }
            }

            // Ê£ÄÊü•Êñá‰ª∂ÁöÑÂÖ∑‰ΩìÊùÉÈôê
            let attributes = try? fileManager.attributesOfItem(atPath: url.path)
            if let permissions = attributes?[.posixPermissions] as? Int {
                os_log(.error, "\(self.t)Êñá‰ª∂ÊùÉÈôê: \(String(format: "%o", permissions))")
            }

            throw error
        }
    }
}

// MARK: Download

extension DiskiCloud {
    func evict(_ url: URL) {
        Task {
            os_log("\(self.label)üèÉüèÉüèÉ Evit \(url.lastPathComponent)")
            do {
                try await cloudHandler.evict(url: url)
            } catch {
                os_log(.error, "\(error.localizedDescription)")
            }
        }
    }

    func download(_ url: URL, reason: String) async throws {
        let verbose = true

        if verbose {
            os_log("\(self.label)Download ‚è¨‚è¨‚è¨ \(url.lastPathComponent) reason üêõ -> \(reason)")
        }

        // Ê£ÄÊü•ÊòØÂê¶‰∏∫ iCloud È°πÁõÆ
        do {
            let resourceValues = try url.resourceValues(forKeys: [.isUbiquitousItemKey])
            guard let isUbiquitousItem = resourceValues.isUbiquitousItem, isUbiquitousItem else {
                if verbose {
                    os_log("\(self.label)‰∏çÊòØ iCloud È°πÁõÆ: \(url.lastPathComponent)")
                }
                return
            }
        } catch {
            os_log(.error, "\(self.label)Ê£ÄÊü• iCloud È°πÁõÆÊó∂Âá∫Èîô: \(error.localizedDescription)")
            return
        }

        // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∑≤‰∏ãËΩΩ
        if iCloudHelper.isDownloaded(url) {
            if verbose {
                os_log("\(self.label)Download \(url.lastPathComponent) -> Already downloaded ‚úÖ‚úÖ‚úÖ")
            }
            return
        }

        // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Ê≠£Âú®‰∏ãËΩΩ
        if iCloudHelper.isDownloading(url) {
            if verbose {
                os_log("\(self.label)Download \(url.lastPathComponent) -> Already downloading ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è")
            }
            return
        }

        let downloadingCount = getDownloadingCount()

        if downloadingCount > 1000 {
            os_log("\(self.label)Download \(url.lastPathComponent) -> Ignore ‚ùÑÔ∏è‚ùÑÔ∏è‚ùÑÔ∏è -> Downloading.count=\(downloadingCount)")

            return
        }

        try await cloudHandler.download(url: url)
    }

    func getDownloadingCount() -> Int {
        var count = 0

        do {
            let files = try FileManager.default.contentsOfDirectory(atPath: self.root.path)
            for file in files {
                if iCloudHelper.isDownloading(URL(fileURLWithPath: root.path).appendingPathComponent(file)) {
                    count += 1
                }
            }
        } catch let e {
            os_log(.error, "\(e.localizedDescription)")
        }

        return count
    }
}

// MARK: Watch

extension DiskiCloud {
    func stopWatch(reason: String) {
        let emoji = "üåõüåõüåõ"

        os_log("\(self.label)\(emoji) ÂÅúÊ≠¢ÁõëÂê¨ because of \(reason)")
        self.query.stop()
    }

    /// ÁõëÂê¨Â≠òÂÇ®AudioÊñá‰ª∂ÁöÑÊñá‰ª∂Â§π
    func watch(reason: String) async {
        let verbose = true

        if verbose {
            os_log("\(self.t)Watch(\(self.name)) because of üêõ \(reason)")
        }

        self.query.stopped = false
        let result = query.searchMetadataItems(predicates: [
            NSPredicate(format: "%K BEGINSWITH %@", NSMetadataItemPathKey, root.path + "/"),
            NSPredicate(format: "NOT %K ENDSWITH %@", NSMetadataItemFSNameKey, ".DS_Store"),
            NSPredicate(format: "NOT %K ENDSWITH %@", NSMetadataItemFSNameKey, ".zip"),
            NSPredicate(format: "NOT %K ENDSWITH %@", NSMetadataItemFSNameKey, ".plist"),
            NSPredicate(format: "NOT %K BEGINSWITH %@", NSMetadataItemFSNameKey, "."),
            NSPredicate(format: "NOT %K BEGINSWITH[c] %@", NSMetadataItemFSNameKey, "."),
        ]).debounce(for: .seconds(0.3))
        for try await collection in result {
            var message = "\(self.t)\(emoji) Watch(\(collection.items.count))"

            if let first = collection.first, first.isDownloading == true {
                message += " -> \(first.fileName ?? "-") -> \(String(format: "%.0f", first.downloadProgress))% ‚è¨‚è¨‚è¨"
            }

            if verbose {
                os_log("\(message)")
            }

            if collection.count == 1, let first = collection.first {
                os_log("   ‚û°Ô∏è FileName: \(first.fileName ?? "nil")")
                os_log("   ‚û°Ô∏è Downloading: \(first.isDownloading ? "true" : "false")")
                os_log("   ‚û°Ô∏è Downloaded: \(first.isDownloaded ? "true" : "false")")
                os_log("   ‚û°Ô∏è Placeholder: \(first.isPlaceholder ? "true" : "false")")
            }

            self.onUpdated(DiskFileGroup.fromMetaCollection(collection, disk: self))
        }
    }
}

// MARK: Move

extension DiskiCloud {
    func moveFile(at sourceURL: URL, to destinationURL: URL) async {
        do {
            try await self.cloudHandler.moveFile(at: sourceURL, to: destinationURL)
        } catch let e {
            os_log(.error, "\(e.localizedDescription)")
        }
    }
}

// MARK: MakeURL

extension DiskiCloud {
    func makeURL(_ fileName: String) -> URL {
        self.root.appending(component: fileName)
    }
}
