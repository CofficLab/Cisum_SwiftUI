---
description: Swift 文件事件监听扩展规则（当抛出事件时，必须为 View 添加 onXxx 监听方法）
globs: *.swift
alwaysApply: false
---
# Swift 文件事件监听扩展规则

本规则约束当 Swift 文件中抛出事件时，必须为 View 扩展添加相应的监听方法，提供便捷的事件监听 API。

## 核心原则

**当 Swift 文件通过 NotificationCenter 或其他方式抛出事件时，必须为 View 扩展添加一个以 `on` 开头的便捷监听方法。**

## 规则详情

### 1. 事件抛出规范

当在 Swift 文件中抛出事件时：

```swift
// ✅ 推荐：通过 NotificationCenter 发送通知
NotificationCenter.default.post(name: .customEvent, object: self)

// ✅ 推荐：使用 Combine PassthroughSubject
let eventSubject = PassthroughSubject<Void, Never>()
eventSubject.send()
```

### 2. View 扩展要求

**必须** 为每个抛出的事件添加对应的 View 扩展方法：

```swift
extension View {
    func onCustomEvent(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .customEvent)) { _ in
            action()
        }
    }
}
```

### 3. 方法命名规范

- **必须以 `on` 开头**：`onEventName`
- **驼峰命名法**：`onApplicationDidBecomeActive`
- **语义清晰**：方法名应清晰表达监听的事件类型
- **参数命名**：使用 `perform action` 参数名

### 4. 调用语法规范

**所有事件监听必须使用 `perform:` 参数语法，一行代码完成：**

```swift
// ✅ 正确：一行代码 + perform 参数
.onProjectDidChangeBranch(perform: onBranchChanged)

// ❌ 错误：使用闭包语法
.onProjectDidChangeBranch { eventInfo in
    onBranchChanged(eventInfo)
}
```

### 5. 实现要求

#### View 扩展实现

```swift
extension View {
    func onEventName(perform action: @escaping (ProjectEventInfo) -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .eventName)) { notification in
            if let userInfo = notification.userInfo, let eventInfo = userInfo["eventInfo"] as? ProjectEventInfo {
                action(eventInfo)
            }
        }
    }
}
```

#### 事件处理方法实现

```swift
extension MyView {
    func onEventName(_ eventInfo: ProjectEventInfo) {
        // 具体业务逻辑在这里实现
        // eventInfo 包含 project, operation, success, error, additionalInfo 等信息

        switch eventInfo.operation {
        case "commit":
            // 处理提交成功事件
            refreshData()
        case "push":
            // 处理推送成功事件
            updateUI()
        default:
            break
        }
    }
}
```

#### Combine Publisher 事件监听

```swift
extension View {
    func onEventName(_ publisher: some Publisher<Void, Never>, perform action: @escaping () -> Void) -> some View {
        self.onReceive(publisher) { _ in
            action()
        }
    }
}
```

### 6. 使用示例

```swift
struct MyView: View {
    var body: some View {
        Text("Hello")
            .onApplicationDidBecomeActive(perform: handleAppDidBecomeActive)
            .onProjectDidCommit(perform: handleCommitSuccess)
    }
}

// MARK: - Event Handlers

extension MyView {
    func handleAppDidBecomeActive(_ eventInfo: ProjectEventInfo) {
        // 处理应用激活事件
        print("App became active!")
        refreshData()
    }

    func handleCommitSuccess(_ eventInfo: ProjectEventInfo) {
        // 处理提交成功事件
        print("Commit successful: \(eventInfo.additionalInfo?["message"] ?? "unknown")")
        updateCommitList()
    }
}
```

## 规则优势

### 1. 提升开发体验

- **语义化 API**：`onEventName` 比 `onReceive(notificationPublisher)` 更直观
- **减少样板代码**：避免在每个 View 中重复编写监听逻辑
- **类型安全**：编译时检查，无运行时错误风险

### 2. 统一代码风格

- **一致性**：所有事件监听都使用相同的命名模式
- **可维护性**：集中管理事件监听逻辑
- **可发现性**：IDE 自动补全 `onXxx` 方法

### 3. 最佳实践

- **解耦合**：View 不需要知道具体的 NotificationCenter 实现
- **可测试性**：事件监听逻辑独立，便于单元测试
- **可重用性**：扩展方法可在项目任何地方使用
- **类型安全**：使用 `ProjectEventInfo` 提供强类型事件数据
- **代码简洁**：一行代码完成事件监听，逻辑分离到独立方法

## 注意事项

- **调用语法**：必须使用 `perform:` 参数语法，一行代码完成事件监听
- **方法签名**：事件处理方法必须接受 `ProjectEventInfo` 参数
- **作用域**：扩展方法应放在抛出事件的同一个文件中，或相关工具文件中
- **命名冲突**：确保 `onXxx` 方法名在项目中唯一
- **线程安全**：确保事件监听在主线程执行 UI 更新操作
- **内存管理**：注意避免循环引用，特别是使用 Combine Publisher 时
- **错误处理**：利用 `ProjectEventInfo` 中的 `success`、`error` 字段进行错误处理

## 常见模式

### 应用生命周期事件

```swift
extension View {
    func onApplicationDidBecomeActive(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .appDidBecomeActive)) { _ in
            action()
        }
    }

    func onApplicationWillBecomeActive(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .appWillBecomeActive)) { _ in
            action()
        }
    }
}
```

### 业务事件监听

```swift
extension View {
    func onProjectLoaded(perform action: @escaping (ProjectEventInfo) -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .projectLoaded)) { notification in
            if let userInfo = notification.userInfo, let eventInfo = userInfo["eventInfo"] as? ProjectEventInfo {
                action(eventInfo)
            }
        }
    }
}

// 使用示例
struct ProjectListView: View {
    var body: some View {
        List(projects) { project in
            Text(project.title)
        }
        .onProjectLoaded(perform: handleProjectLoaded)
    }
}

extension ProjectListView {
    func handleProjectLoaded(_ eventInfo: ProjectEventInfo) {
        if eventInfo.success {
            // 刷新项目列表
            loadProjects()
        } else {
            // 处理加载失败
            showError(eventInfo.error)
        }
    }
}
```

遵循此规则可以显著提升代码的可读性、可维护性和开发体验。