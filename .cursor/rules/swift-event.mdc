---
description: Swift 文件事件监听扩展规则（当抛出事件时，必须为 View 添加 onXxx 监听方法）
globs: *.swift
alwaysApply: false
---
# Swift 文件事件监听扩展规则

本规则约束当 Swift 文件中抛出事件时，必须为 View 扩展添加相应的监听方法，提供便捷的事件监听 API。

## 文件组织规范

**所有事件相关代码必须统一放在 `Core/Events/` 目录中：**

- `AppEvents.swift` - 应用生命周期事件定义和扩展
- `SettingEvents.swift` - 设置相关事件定义和扩展
- 其他领域事件文件按需添加

**禁止将事件扩展代码放在其他位置**，确保事件系统的集中管理和维护。

## 核心原则

**当 Swift 文件通过 NotificationCenter 或其他方式抛出事件时，必须为 View 扩展添加一个以 `on` 开头的便捷监听方法。**

## 规则详情

### 1. 事件抛出规范

当在 Swift 文件中抛出事件时：

```swift
// ✅ 推荐：通过 NotificationCenter 发送通知
NotificationCenter.default.post(name: .customEvent, object: self)

// ✅ 推荐：使用 Combine PassthroughSubject
let eventSubject = PassthroughSubject<Void, Never>()
eventSubject.send()
```

### 2. View 扩展要求

**必须** 为每个抛出的事件添加对应的 View 扩展方法：

```swift
extension View {
    func onCustomEvent(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .customEvent)) { _ in
            action()
        }
    }
}
```

### 3. 方法命名规范

- **必须以 `on` 开头**：`onEventName`
- **驼峰命名法**：`onApplicationDidBecomeActive`
- **语义清晰**：方法名应清晰表达监听的事件类型
- **参数命名**：使用 `perform action` 参数名

### 4. 调用语法规范

**所有事件监听必须使用 `perform:` 参数语法，一行代码完成：**

```swift
// ✅ 正确：一行代码 + perform 参数
.onProjectDidChangeBranch(perform: onBranchChanged)

// ❌ 错误：使用闭包语法
.onProjectDidChangeBranch { eventInfo in
    onBranchChanged(eventInfo)
}
```

### 5. 实现要求

#### 文件组织结构
**所有事件相关代码必须放在 `Core/Events` 目录中：**

- `AppEvents.swift` - 应用生命周期事件
- `SettingEvents.swift` - 设置相关事件
- 其他特定领域的事件文件

#### View 扩展实现

```swift
// 在 Core/Events/ 目录的相应文件中实现
extension View {
    func onEventName(perform action: @escaping (ProjectEventInfo) -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .eventName)) { notification in
            if let userInfo = notification.userInfo, let eventInfo = userInfo["eventInfo"] as? ProjectEventInfo {
                action(eventInfo)
            }
        }
    }
}
```

#### 事件处理方法实现

```swift
extension MyView {
    func onEventName(_ eventInfo: ProjectEventInfo) {
        // 具体业务逻辑在这里实现
        // eventInfo 包含 project, operation, success, error, additionalInfo 等信息

        switch eventInfo.operation {
        case "commit":
            // 处理提交成功事件
            refreshData()
        case "push":
            // 处理推送成功事件
            updateUI()
        default:
            break
        }
    }
}
```

#### Combine Publisher 事件监听

```swift
extension View {
    func onEventName(_ publisher: some Publisher<Void, Never>, perform action: @escaping () -> Void) -> some View {
        self.onReceive(publisher) { _ in
            action()
        }
    }
}
```

### 6. 使用示例

```swift
// ContentView.swift - 使用事件监听
struct ContentView: View {
    var body: some View {
        VStack {
            Text("Hello")
        }
        .onApplicationDidFinishLaunching(perform: handleAppLaunch)
        .onOpenSettings(perform: handleOpenSettings)
    }
}

// MARK: - Event Handlers

extension ContentView {
    func handleAppLaunch() {
        // 处理应用启动完成事件
        print("Application launched successfully!")
        // 执行应用初始化逻辑
    }

    func handleOpenSettings() {
        // 处理打开设置事件
        showSettings = true
    }
}
```

## 注意事项

- **调用语法**：必须使用 `perform:` 参数语法，一行代码完成事件监听
- **方法签名**：事件处理方法必须接受 `ProjectEventInfo` 参数
- **文件组织**：所有事件扩展方法必须放在 `Core/Events/` 目录中相应的文件中
- **命名冲突**：确保 `onXxx` 方法名在项目中唯一
- **线程安全**：确保事件监听在主线程执行 UI 更新操作
- **内存管理**：注意避免循环引用，特别是使用 Combine Publisher 时
- **错误处理**：利用 `ProjectEventInfo` 中的 `success`、`error` 字段进行错误处理

## 常见模式

### 应用生命周期事件

**文件位置**: `Core/Events/AppEvents.swift`

```swift
// 应用生命周期事件扩展
extension View {
    func onApplicationDidFinishLaunching(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .applicationDidFinishLaunching)) { _ in
            action()
        }
    }

    func onApplicationWillTerminate(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .applicationWillTerminate)) { _ in
            action()
        }
    }

    func onApplicationDidBecomeActive(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .applicationDidBecomeActive)) { _ in
            action()
        }
    }

    func onApplicationDidResignActive(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .applicationDidResignActive)) { _ in
            action()
        }
    }
}
```

### 设置相关事件

**文件位置**: `Core/Events/SettingEvents.swift`

```swift
// 设置相关事件扩展
extension View {
    func onOpenSettings(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .openSettings)) { _ in
            action()
        }
    }

    func onDismissSettings(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .dismissSettings)) { _ in
            action()
        }
    }
}
```

### 使用示例

```swift
// 在任意View中使用事件监听
struct MyView: View {
    @State private var showSettings = false

    var body: some View {
        VStack {
            Text("Welcome to SwiftUI Template")
            Button("Open Settings") {
                NotificationCenter.postOpenSettings()
            }
        }
        .sheet(isPresented: $showSettings) {
            SettingView()
        }
        .onOpenSettings(perform: handleOpenSettings)
        .onApplicationDidBecomeActive(perform: handleAppActivated)
    }
}

extension MyView {
    func handleOpenSettings() {
        showSettings = true
    }

    func handleAppActivated() {
        print("App became active - refresh data if needed")
    }
}
```

遵循此规则可以显著提升代码的可读性、可维护性和开发体验。
